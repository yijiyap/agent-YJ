import { fileURLToPath } from 'node:url';
import { normalize } from 'node:path';
import { defineNuxtModule, createResolver, addPlugin, addPluginTemplate, addServerHandler, addImports } from '@nuxt/kit';
import { markRaw } from 'vue';
import { consola } from 'consola';
import { access, constants, readFile } from 'node:fs/promises';
import stripJsonComments from 'strip-json-comments';

async function willUseEmulators({ emulators }, firebaseJsonPath, logger) {
  const isEmulatorEnabled = (
    // emulators is always defined
    emulators.enabled && // Disable emulators on production unless the user explicitly enables them
    (process.env.NODE_ENV !== "production" || process.env.VUEFIRE_EMULATORS && process.env.VUEFIRE_EMULATORS !== "false")
  );
  if (!isEmulatorEnabled) {
    return null;
  }
  if (await access(firebaseJsonPath, constants.F_OK).catch(() => true)) {
    logger.warn(
      `The "firebase.json" file doesn't exist at "${firebaseJsonPath}".`
    );
    return null;
  }
  let firebaseJson = null;
  try {
    firebaseJson = JSON.parse(
      stripJsonComments(await readFile(firebaseJsonPath, "utf8"), {
        trailingCommas: true
      })
    );
  } catch (err) {
    logger.error("Error parsing the `firebase.json` file", err);
    logger.error("Cannot enable Emulators");
  }
  return firebaseJson?.emulators ?? null;
}
function detectEmulators({
  emulators: _vuefireEmulatorsOptions,
  auth
}, firebaseEmulatorsConfig, logger) {
  const vuefireEmulatorsOptions = typeof _vuefireEmulatorsOptions === "object" ? _vuefireEmulatorsOptions : {
    enabled: _vuefireEmulatorsOptions
  };
  if (!firebaseEmulatorsConfig) {
    if (vuefireEmulatorsOptions.enabled !== false) {
      logger.warn(
        "You enabled emulators but there is no `emulators` key in your `firebase.json` file. Emulators will not be enabled."
      );
    }
    return;
  }
  const defaultHost = vuefireEmulatorsOptions.host || "127.0.0.1";
  const emulatorsToEnable = services.reduce((acc, service) => {
    if (firebaseEmulatorsConfig[service]) {
      const envKey = service === "firestore" ? "FIRESTORE_EMULATOR_HOST" : `FIREBASE_${service.toUpperCase()}_EMULATOR_HOST`;
      let host;
      let port;
      if (process.env[envKey]) {
        logger.debug(
          `Using the "${envKey}" env variable to enable the "${service}" emulator.`
        );
        try {
          const url = new URL(`http://${process.env[envKey]}`);
          host = url.hostname;
          port = Number(url.port);
        } catch (err) {
          logger.error(
            `The "${envKey}" env variable is set but it is not a valid URL. It should be something like "127.0.0.1:8080". It will be ignored in favor of the "firebase.json" values.`
          );
        }
      }
      const emulatorsServiceConfig = firebaseEmulatorsConfig[service];
      host ?? (host = emulatorsServiceConfig?.host || defaultHost);
      port ?? (port = emulatorsServiceConfig?.port);
      const missingHostServices = [];
      if (emulatorsServiceConfig?.host == null) {
        missingHostServices.push(service);
      } else if (emulatorsServiceConfig.host !== host) {
        logger.error(
          `The "${service}" emulator is enabled but the "host" property in the "emulators.${service}" section of your "firebase.json" file is different from the "vuefire.emulators.host" value. You might encounter errors in your app if this is not fixed.`
        );
      }
      if (missingHostServices.length > 0 && host !== "127.0.0.1") {
        logger.warn(
          `The "${service.at(
            0
          )}" emulator is enabled but there is no "host" key in the "emulators.${service}" key of your "firebase.json" file. It is recommended to set it to avoid mismatches between origins. You should probably set it to "${defaultHost}" ("vuefire.emulators.host" value).` + (missingHostServices.length > 1 ? ` The following emulators are also missing the "host" key: ${missingHostServices.slice(1).join(", ")}.` : "")
        );
      }
      if (!port) {
        logger.error(
          `The "${service}" emulator is enabled but there is no "port" property in the "emulators" section of your "firebase.json" file. It must be specified to enable emulators. The "${service}" emulator won't be enabled.`
        );
        return acc;
      } else if (emulatorsServiceConfig && emulatorsServiceConfig.port !== port) {
        logger.error(
          `The "${service}" emulator is enabled but the "port" property in the "emulators.${service}" section of your "firebase.json" file is different from the "${envKey}" env variable. You might encounter errors in your app if this is not fixed.`
        );
      }
      acc[service] = { host, port };
    }
    return acc;
  }, {});
  if (!auth) {
    delete emulatorsToEnable.auth;
    if (process.env.FIREBASE_AUTH_EMULATOR_HOST) {
      logger.warn(
        `The "FIREBASE_AUTH_EMULATOR_HOST" env variable is set but the "vuefire.auth" option is not enabled. The env variable will be ignored and the auth emulator won't be enabled.`
      );
      delete process.env.FIREBASE_AUTH_EMULATOR_HOST;
    }
  }
  return emulatorsToEnable;
}
const services = [
  "auth",
  "database",
  "firestore",
  "functions",
  "storage"
];

const logger = consola.withTag("nuxt-vuefire module");
const module = defineNuxtModule({
  meta: {
    name: "vuefire",
    configKey: "vuefire",
    compatibility: {
      nuxt: "^3.1.0"
    }
  },
  defaults: {
    optionsApiPlugin: false,
    emulators: { enabled: true }
  },
  async setup(options, nuxt) {
    var _a, _b, _c, _d, _e;
    if (!options.config) {
      throw new Error(
        '[nuxt-vuefire]: Missing firebase config. Provide a "config" option to the VueFire module options.'
      );
    }
    const { resolve } = createResolver(import.meta.url);
    const runtimeDir = fileURLToPath(new URL("./runtime", import.meta.url));
    const templatesDir = fileURLToPath(new URL("../templates", import.meta.url));
    nuxt.options.appConfig.firebaseConfig = markRaw(options.config);
    nuxt.options.appConfig.vuefireOptions = markRaw(options);
    const isAuthEnabled = typeof options.auth === "object" ? options.auth.enabled ?? true : !!options.auth;
    const resolvedVueFireOptions = {
      ...options,
      // ensure the resolved version easier to consume
      emulators: {
        enabled: typeof options.emulators === "object" ? options.emulators.enabled ?? true : !!options.emulators,
        ...typeof options.emulators === "object" ? options.emulators : {}
      },
      auth: {
        enabled: isAuthEnabled,
        // enable session cookie when auth is `true`
        sessionCookie: typeof options.auth === "object" ? isAuthEnabled && options.auth.sessionCookie : !!options.auth,
        // fallback to the boolean value of options.auth
        ...typeof options.auth === "object" ? options.auth : {}
      }
    };
    nuxt.options.runtimeConfig.vuefire = {
      options: resolvedVueFireOptions
    };
    const emulatorsConfig = await willUseEmulators(
      nuxt.options.runtimeConfig.vuefire.options,
      resolve(nuxt.options.rootDir, "firebase.json"),
      logger
    );
    addPlugin(resolve(runtimeDir, "payload-plugin"));
    nuxt.options.build.transpile.push(runtimeDir);
    nuxt.options.build.transpile.push(templatesDir);
    if (typeof options.admin?.serviceAccount === "string") {
      (_a = process.env).GOOGLE_APPLICATION_CREDENTIALS || (_a.GOOGLE_APPLICATION_CREDENTIALS = options.admin.serviceAccount);
    }
    const hasServiceAccount = typeof process.env.GOOGLE_APPLICATION_CREDENTIALS === "string" && process.env.GOOGLE_APPLICATION_CREDENTIALS.length > 0;
    if (typeof process.env.GOOGLE_APPLICATION_CREDENTIALS === "string" && process.env.GOOGLE_APPLICATION_CREDENTIALS?.[0] !== "{") {
      const resolvedCredentials = resolve(
        nuxt.options.rootDir,
        process.env.GOOGLE_APPLICATION_CREDENTIALS
      );
      process.env.GOOGLE_APPLICATION_CREDENTIALS = resolvedCredentials;
    }
    if (options.appCheck) {
      if (!process.env.GOOGLE_APPLICATION_CREDENTIALS && emulatorsConfig) {
        logger.info(
          'Disabling App Check in the context of emulators as no "GOOGLE_APPLICATION_CREDENTIALS" env variable was defined.'
        );
      } else {
        if (process.env.FIREBASE_APPCHECK_DEBUG_TOKEN && // only use the debug token if the user explicitly set debug to true or if nothing was provided and we are not in production
        (options.appCheck.debug === true || // allow a manual override from the console before bundling
        process.env.VUEFIRE_APPCHECK_DEBUG || options.appCheck.debug == null && process.env.NODE_ENV !== "production")) {
          logger.debug(
            `Using app check debug token from env variable "${process.env.FIREBASE_APPCHECK_DEBUG_TOKEN}"`
          );
          if (process.env.NODE_ENV === "production" && options.appCheck.debug) {
            logger.warn(
              "You are using a debug token in production, DO NOT DEPLOY THIS BUILD. If you do, you will leak your debug app check token."
            );
          }
          options.appCheck.debug = process.env.FIREBASE_APPCHECK_DEBUG_TOKEN;
        } else if (emulatorsConfig) {
          logger.debug("Detected Emulators environment, using debug App Check");
          (_b = options.appCheck).debug ?? (_b.debug = true);
        }
        addPlugin(resolve(runtimeDir, "app-check/plugin.client"));
        if (hasServiceAccount || emulatorsConfig) {
          addPlugin(resolve(runtimeDir, "app-check/plugin.server"));
        } else if (nuxt.options.ssr && !emulatorsConfig) {
          logger.warn(
            "You activated both SSR and app-check but you are not providing a service account for the admin SDK. See https://vuefire.vuejs.org/nuxt/getting-started.html#configuring-the-admin-sdk."
          );
        }
      }
    }
    addPluginTemplate({
      src: normalize(resolve(templatesDir, "plugin.ejs")),
      options: {
        ...options,
        ssr: nuxt.options.ssr
      }
    });
    if (options.auth) {
      if (nuxt.options.ssr && !hasServiceAccount && !emulatorsConfig) {
        logger.warn(
          "You activated both SSR and auth but you are not providing a service account for the admin SDK. See https://vuefire.vuejs.org/nuxt/getting-started.html#configuring-the-admin-sdk."
        );
      }
      if (nuxt.options.ssr && (hasServiceAccount || emulatorsConfig) && resolvedVueFireOptions.auth.sessionCookie) {
        addServerHandler({
          route: "/api/__session",
          handler: resolve(runtimeDir, "./auth/api.session-verification")
        });
        addPlugin(resolve(runtimeDir, "auth/plugin-mint-cookie.client"));
      }
      addPlugin(resolve(runtimeDir, "auth/plugin.client"));
      addPlugin(resolve(runtimeDir, "auth/plugin.server"));
      addVueFireImports([
        // auth
        { from: "vuefire", name: "useFirebaseAuth" },
        { from: "vuefire", name: "useCurrentUser" }
      ]);
      addImports([
        {
          from: resolve(runtimeDir, "auth/composables"),
          name: "getCurrentUser"
        }
      ]);
    }
    if (emulatorsConfig) {
      const emulators = detectEmulators(
        nuxt.options.runtimeConfig.vuefire.options,
        emulatorsConfig,
        logger
      );
      if (emulators?.auth) {
        emulators.auth.options = nuxt.options.runtimeConfig.vuefire.options?.emulators?.auth?.options;
      }
      (_c = nuxt.options.runtimeConfig.public).vuefire ?? (_c.vuefire = {});
      nuxt.options.runtimeConfig.public.vuefire.emulators = emulators;
      for (const serviceName in emulators) {
        const { host, port } = emulators[serviceName];
        process.env[serviceName === "firestore" ? "FIRESTORE_EMULATOR_HOST" : `FIREBASE_${serviceName.toUpperCase()}_EMULATOR_HOST`] = `${host}:${port}`;
        logger.info(`Enabling ${serviceName} emulator at ${host}:${port}`);
        addPlugin(resolve(runtimeDir, `emulators/${serviceName}.plugin`));
      }
    }
    addPlugin(resolve(runtimeDir, "app/plugin.client"));
    addPlugin(resolve(runtimeDir, "app/plugin.server"));
    if (options.admin || nuxt.options.ssr) {
      if (!nuxt.options.ssr) {
        logger.warn(
          'The "admin" option is only used during SSR. You should reenable SSR to use it or remove it if you are not doing SSR or SSG.'
        );
      }
      if (hasServiceAccount || emulatorsConfig) {
        if (resolvedVueFireOptions.auth.sessionCookie) {
          addPlugin(resolve(runtimeDir, "auth/plugin-user-token.server"));
        }
        addPlugin(resolve(runtimeDir, "admin/plugin.server"));
        if (emulatorsConfig) {
          options.admin ?? (options.admin = {});
          (_d = options.admin).options ?? (_d.options = {});
          (_e = options.admin.options).projectId ?? (_e.projectId = options.config.projectId);
        }
      }
    }
    addImports([
      // app
      {
        from: resolve(runtimeDir, "app/composables"),
        name: "useFirebaseApp"
      }
    ]);
    addVueFireImports([
      // firestore
      { from: "vuefire", name: "useFirestore" },
      { from: "vuefire", name: "useDocument" },
      { from: "vuefire", name: "useCollection" },
      // database
      { from: "vuefire", name: "useDatabase" },
      { from: "vuefire", name: "useDatabaseList" },
      { from: "vuefire", name: "useDatabaseObject" },
      // storage
      { from: "vuefire", name: "useFirebaseStorage" },
      { from: "vuefire", name: "useStorageFile" },
      { from: "vuefire", name: "useStorageFileUrl" },
      { from: "vuefire", name: "useStorageFileMetadata" }
    ]);
  },
  // workaround for vite
  hooks: {
    "vite:extendConfig": (viteInlineConfig, env) => {
      var _a, _b;
      viteInlineConfig.resolve ?? (viteInlineConfig.resolve = {});
      (_a = viteInlineConfig.resolve).dedupe ?? (_a.dedupe = []);
      const deps = [
        // 'vuefire',
        // 'nuxt-vuefire',
        "firebase",
        "firebase/app",
        "@firebase/app",
        "firebase/firestore",
        "@firebase/firestore",
        "firebase/auth",
        "@firebase/auth",
        "@firebase/component",
        "firebase-admin/auth",
        "firebase-admin/app",
        "firebase-admin/app-check"
      ];
      viteInlineConfig.resolve.dedupe.push(...deps);
      viteInlineConfig.optimizeDeps ?? (viteInlineConfig.optimizeDeps = {});
      (_b = viteInlineConfig.optimizeDeps).exclude ?? (_b.exclude = []);
      viteInlineConfig.optimizeDeps.exclude.push(...deps);
    }
  }
});
function addVueFireImports(imports) {
  return addImports(imports);
}

export { module as default };
